# Документация

### Справочник 

* [Где установить интерпретатор?](#установка-интерпретатора)

* [Где установить компилятор?](#установка-компилятора)

* [Вывод в консоль](#вывод-в-консоль)

  * [Операционный перевод текста на новую строку](#операционный-переход-на-новую-строку)
  * [Функция `outln`](#функция-outln-для-автоматического-перехода-на-новую-строку)

* [Комментарий](#комментарий)
* [Типы данных](#типы-данных)
  * [Список типов данных](#список-типов-данных)
  * [Размеры типов данных](#размеры-типов-данных-в-байтах)
  * [Диапазоны целочисленных типов данных](#диапазоны-целочисленных-типов-данных)

* [Переменные](#переменные)
  * [Как создать переменные?](#как-создать-переменные)
  * [Динамическая типизация](#динамическая-типизация)
  * [Статическая типизация](#статическая-типизация)

* [Ввод из консоли](#ввод-из-консоли)

* [Функция `main` как точка входа](#функция-main-как-точка-входа)
  * [Полный синтаксис функций `main`](#полный-синтаксис-функций-main)

* [Преобразование типов](#преобразование-типов)
* [Операторы сравнения](#операторы-сравнения)
* [Логические операторы](#логические-операторы)
# Установка интерпретатора

На данный момент интерпретатора нет.

# Установка компилятора

На данный момент компилятора нет.

# Вывод в консоль

В каждом языке программирования есть **функция** или **операция** для вывода какой-то информаций на экран пользователя. В **QuarkScript** такую роль исполняет функция `out` из **модуля** `std`, представляющий стандартный **модуль** языка.

### Словарь

* #### Функция - это исполняющий код программы, выполняющий какую то задачу.
* #### Модуль - в QuarkScript это конструкция, позволяющая хранить объекты и избавляться от конфликтов имен в программе
* #### `out` - Функция для вывода
* #### `std` - Модуль, хранящий функцию `out` 
* #### `->` - Оператор, который позволяет обратиться к объекту модуля.

Для обращения к **объекту** модуля следует использовать **оператор стрелочки**. Пишется он так:

```qs
std->out;
```
Так как это функция, все что нам нужно прописать круглые скобки для вывода информаций на экран и эту же информацию поместить внутри скобок, например **строку**:

```qs
std->out("Hello, World!");
```

На выходе в консоли мы увидим

```ps
Hello, World
```

Возникает вопрос об загадочном изчезновений кавычек. Куда же все таки они делись? На самом деле компьютер пропускает кавычки и читает только то, что внутри них. Потому что он считает первой кавычкой началом строки а второй кавычкой концом строки.


## Операционный переход на новую строку
Если вы ввели подряд две функций `out` с новой строки и надеетесь что первая функция `out` перейдет на новую строку автоматически после вывода, то нет. Вам нужно делать это вручную с помощью функций `newl`:

```qs
std->out("Hello,", std->newl());
std->out("I am your friend!");
```
Как вы увидели разделителем для строки и функций `newl` (кстати из того же модуля `std`) является запятая.

## Функция `outln` для автоматического перехода на новую строку
Однако если вам не хочется пользоваться `newl` то можно использовать функцию `outln` из модуля `std`:

```qs
std->outln("Hello,");
std->out("I am your friend!");
```

Он автоматически совершит переход текста на новую строку.

# Комментарий

Это пометки, облегчающие разработку

```qs
// Это однострочный комментарий
/*
Это многострочный комментарий
Вот так
*/
```
# Типы данных

QuarkScript представляет широкий диапазон типов для удовлетворений потребностей программистов. Например **целочисленные типы, символьные, строковые, массивы, числы с плавающей точкой** и т.д. Вообщем он насчитывает **11** встроенных типов данных.

## Список типов данных

* #### `Int` - Целочисленный тип
* #### `Float` - Численный тип с плавающей точкой
* #### `Char` - Целочисленный тип, хранящий символ в кодировке ASCII
* #### `String` - Тип, описывающий строку. Часто является массивом Char или UniChar
* #### `Array` - Массив, для хранения нескольких значений в одном объекте
* #### `Bool` - Логический тип. Содержит исключительно 2 булевых значения.
* #### `Variant` - Любой тип
* #### `Unsigned` - Модификатор типа, представляющий беззнаковый тип
* #### `Signed` - Модификатор типа, представляющий знаковый тип
* #### `UniChar` - Целочисленный тип, хранящий символ в кодировке UniCode (UTF-8)
* #### `Void` - Пустой тип.

## Размеры типов данных в байтах

* #### `Int` - 4 байта (32 бита)
* #### `Float` - 4 байта (32 бита)
* #### `Char` - 1 байт (8 бит)
* #### `String` - динамически
* #### `Array` - динамически
* #### `Bool` - 1 байт (8 бит)
* #### `Variant` - динамически
* #### `Unsigned` - 0 байт (просто модификация)
* #### `Signed` - 0 байт (просто модификация)
* #### `UniChar` - 2 байта (16 бит)
* #### `Void` - 0 байт

## Диапазоны целочисленных типов данных
* #### `Int` - от -2147483648 до 2147483647
  * #### `Unsigned Int` - от 0 до 4294967295
  * #### `Signed Int` - от -2147483648 до 2147483647
* #### `Float` - от +/- 3.4E-38 до 3.4E+38=
* #### `Char` - от 0 до 255
  * #### `Unsigned Char` - от 0 до 255
  * #### `Signed Char` - от -128 до 127
* #### `String` - неограничено
* #### `Array` - неограничено 
* #### `Bool` - от 0 до 1. Только false и true
* #### `Variant` - динамически или неограничено
* #### `Unsigned` - модификатор
* #### `Signed` - модификатор
* #### `UniChar` - от U+0000 до U+10FFFF
* #### `Void` - Пустой тип

# Переменные

Переменные - это объекты, которые хранят в себе информацию разного типа. Они имеют своё имя и место. Переменные уникальны. Поэтому вы не сможете создать две или более переменных с одним именем. Но можете создать две или более переменных с разными значениями. При условий что имена этих переменных будут отличны друг от друга

## Как создать переменные?

Переменные создаются с помощью ключевого слова `var`. Создаются они по такому шаблону:

```qs
var имя := значение;
```

## Динамическая типизация

В этом случае тебе не нужно заботиться о указаний типа переменной. За тебя это сделает интерпретатор.

## Статическая типизация

В этом случае ты можешь указать тип переменной. И интерпретатор не будет тратить время на установку типа значения переменной:

```qs
var n : Int = 50;
```

# Ввод из консоли

Ввод из консоли осуществляется с помощью функций `input` из модуля `std`:

```qs
std->out("Enter value: ");

var value : Int;

std->input(value);
```

В этом примере мы сохранили ввод из консоли в переменную value.

# Функция `main` как точка входа

Для запуска программы необходима точка входа в программу. Сейчас мы сделаем свою функцию для точки входа. Она будет называться `main`:

```qs
func main()
{
    std->outln("Hello, World!");
}
```

Без этой функций программа не запустится.

## Полный синтаксис функций `main`

Полный синтаксис этой функций выглядит следующим образом:

```qs
func main(Void) -> Int
{
    return 0;
}
```

Тип `Void` сообщает о том, что это функция не принимает никаких аргументов внутри скобок. Тип `Int` после стрелочки `->` сообщает о том что эта функция возвращает целочисленный тип `Int`. Фрагмент `return 0` говорит о том, что эта функция возвращает целочисленное значение `0` и что функция завершилась успешно.

# Преобразование типов

Операция преобразования типов позволяет преобразовать тип одного объекта в другой тип. Например если вы хотите преобразовать тип `Char` в `Int` и получить `Ascii` код символа то вам нужно сделать так:

```qs
Int('N')
```

В результате получится `78` т.к это `Ascii` код символа `N`.

### Справочник

* #### `Int(Object)` - Преобразует тип Object в Int
* #### `Float(Object)` - Преобразует тип Object в Float
* #### `Char(Object)` - Преобразует тип Object в Char
* #### `String(Object)` - Преобразует тип Object в String
* #### `Array(Object)` - Преобразует тип Object в Array
* #### `Bool(Object)` - Преобразует тип Object в Bool
* #### `Variant(Object)` - Невозможно преобразовать
* #### `Unsigned(Object)` - Невозможно преобразовать
* #### `Signed(Object)` - Невозможно преобразовать
* #### `UniChar` - Преобразует тип Object в UniChar
* #### `Void` - Преобразует тип Object в Void (Осторожно!)

# Операторы сравнения

QuarkScript позволяет не только хранить данные. Но так же может выполнять алгоритмические задачи разного рода. И для этого он содержит **операторы сравнения**. Эти операторы сравнивают **первое значение** со **вторым значением** и возвращают тип **Bool**.

### Справочник

* #### `a == b` - Возвращает true если `a` равен `b`
* #### `a != b` - Возвращает true если `a` не равен `b`.
* #### `a > b` - Возвращает true если `a` больше чем `b`
* #### `a < b` - Возвращает true если `a` меньше чем `b`
* #### `a >= b` - Возвращает true если `a` больше или равно `b`
* #### `a <= b` - Возвращает true если `a` меньше или равно `b`

Пример кода:

```qs
var a := 5;
var b := 6;
var result := a > b;
std->out(result);
```
Результатом будет false. Так как a=5 меньше чем b=6.
# Логические операторы
Есть несколько операторов, которые могут помочь в ветвлениях. Например такие как **И**, **ИЛИ**, **НЕ**.

### Справочник
* #### `a && b` - Возвращает `true` если ОБА операнда ненулевые
* #### `a and b` - Тоже самое

* #### `a || b` - Возвращает `true` если хотя бы ОДИН из этих операндов или ОБА этих операндов ненулевые
* #### `a or b` - Тоже самое

* #### `!a` - Инвертирует `a` в `true` если `a = false` и в `false` если `a = true`
* #### `not a` - Тоже самое